@page "/AudioWorklets"
@using KristofferStrube.Blazor.DOM
@implements IAsyncDisposable
@inject IJSRuntime JSRuntime
<PageTitle>WebAudio - Audio Worklets</PageTitle>
<h2>Audio Worklets</h2>

<p>Here we can play sound that is generated using Audio Worklet Processors that can manipulate or generate sound in any custom way.</p>

@if (worktletNode is null)
{
    <div style="display:flex; flex-direction:column; grid-gap: 5px;">
        <button class="btn btn-success" @onclick=PlayWhiteSound>Play Sound from static JS White Noise Generator</button>
        <hr />
        <button class="btn btn-success" @onclick=PlayPushProcessedSound>Play Sound that is pushed from Blazor</button>
        <div>
            <label for="lowTide">Low Tide</label>
            <input id="lowTide" @bind=lowTide />
        </div>
        <div>
            <label for="highTide">High Tide</label>
            <input id="highTide" @bind=highTide />
        </div>
        <div>
            <label for="bufferRequestSize">Buffer Request Size</label>
            <input id="bufferRequestSize" @bind=bufferRequestSize />
        </div>
        <hr />
    </div>
}
else
{
    <button class="btn btn-warning" @onclick=StopSound>Stop Sound</button>
}
<br />
<GainSlider GainNode=gainNode />

@code {
    int lowTide = 100;
    int highTide = 500;
    int bufferRequestSize = 100;

    AudioContext? context;

    AudioWorkletNode? worktletNode;
    MessagePort? messagePort;
    EventListener<MessageEvent>? messageEventListener;

    AudioDestinationNode? destination;
    GainNode? gainNode;

    public async Task PlayWhiteSound()
    {
        // Get context.
        context = await AudioContext.CreateAsync(JSRuntime);

        // Register module
        await using AudioWorklet audioWorklet = await context.GetAudioWorkletAsync();
        await audioWorklet.AddModuleAsync("js/white-noise.js");

        // Create node from registered processor.
        worktletNode = await AudioWorkletNode.CreateAsync(JSRuntime, context, "white-noise");

        // Get destination and connect worklet node through gainNode
        destination = await context.GetDestinationAsync();
        gainNode = await GainNode.CreateAsync(JSRuntime, context, new() { Gain = 0.05f });
        await worktletNode.ConnectAsync(gainNode);
        await gainNode.ConnectAsync(destination);
    }

    public async Task PlayPushProcessedSound()
    {
        // Get context.
        context = await AudioContext.CreateAsync(JSRuntime);

        // Register module
        await using AudioWorklet audioWorklet = await context.GetAudioWorkletAsync();
        await audioWorklet.AddModuleAsync("./_content/KristofferStrube.Blazor.WebAudio/KristofferStrube.Blazor.WebAudio.PushAudioProcessor.js");

        // Create node from registered processor.
        worktletNode = await AudioWorkletNode.CreateAsync(JSRuntime, context, "kristoffer-strube-webaudio-push-audio-processor", new()
            {
                ParameterData = new()
                {
                    ["lowTide"] = lowTide,
                    ["highTide"] = highTide,
                    ["bufferRequestSize"] = bufferRequestSize,
                }
            });

        // Get destination and connect worklet node through gainNode
        destination = await context.GetDestinationAsync();
        gainNode = await GainNode.CreateAsync(JSRuntime, context, new() { Gain = 0.05f });
        await worktletNode.ConnectAsync(gainNode);
        await gainNode.ConnectAsync(destination);

        // Get MessagePort and set up event listener for messages from the worklet.
        messagePort = await worktletNode.GetPortAsync();
        await messagePort.StartAsync();
        messageEventListener = await EventListener<MessageEvent>.CreateAsync(JSRuntime, async (e) =>
        {
            var dataNeededToReachLowTide = await e.GetDataAsync<int>();
            Console.WriteLine(dataNeededToReachLowTide);
            await messagePort.PostMessageAsync(
                Enumerable
                .Range(0, dataNeededToReachLowTide)
                    .Select(
                        _ => Enumerable.Range(0, 128).Select(_ => Random.Shared.NextDouble() * 2 - 1).ToArray()
                    ).ToArray()
            );
        });
        await messagePort.AddOnMessageEventListenerAsync(messageEventListener);

        await messagePort.PostMessageAsync(
            Enumerable
                .Range(0, 100)
                .Select(
                    _ => Enumerable.Range(0, 128).Select(_ => Random.Shared.NextDouble() * 2 - 1).ToArray()
                ).ToArray()
        );
    }

    public async Task StopSound()
    {
        if (context is not null)
        {
            await context.DisposeAsync();
        }

        if (gainNode is not null)
        {
            await gainNode.DisposeAsync();
            gainNode = null;
        }

        if (destination is not null)
        {
            await destination.DisposeAsync();
            destination = null;
        }

        if (messageEventListener is not null && messagePort is not null)
        {
            await messagePort.RemoveOnMessageEventListenerAsync(messageEventListener);
            await messageEventListener.DisposeAsync();
            messageEventListener = null;
        }

        if (messagePort is not null)
        {
            await messagePort.CloseAsync();
            await messagePort.DisposeAsync();
            messagePort = null;
        }

        if (worktletNode is not null)
        {
            await worktletNode.DisconnectAsync();
            await worktletNode.DisposeAsync();
            worktletNode = null;
        }
    }

    public async ValueTask DisposeAsync()
    {
        await StopSound();
    }
}


