@page "/Spectogram"
@using KristofferStrube.Blazor.WebIDL
@implements IAsyncDisposable
@inject IJSRuntime JSRuntime
<PageTitle>WebAudio - Spectogram</PageTitle>

<h2>Spectogram</h2>
<p>
    On this page we create a spectogram by passing the sound of a random <code>OscillatorNode</code> through a <code>AnalyserNode</code>.
</p>

@if (oscillator is null)
{
    <button class="btn btn-success" @onclick=PlaySound>Play Sound 🔊</button>
}
else
{
    <button class="btn btn-warning" @onclick=StopSound>Stop Sound 🔊</button>
}
<br />
<GainSlider @ref=gainSlider GainNode="gainNode" /><span class="badge bg-primary">@Math.Round(gainSlider?.Gain*100 ?? 0, 0)%</span>
<br />
<label for="measurementDelay">Additional Measurement Delay</label>
<input @bind-value=measurementDelay
@bind-value:event="oninput"
       id="measurementDelay"
       type="range"
       min="1"
       max="500"
       step="1"
       style="width:min(200px, 100%);" />
<span class="badge bg-primary">@measurementDelay ms</span>
@if (frequency is not 0)
{
    <div>
        frequency: @frequency Hz
        <br />
        type: @type
    </div>
}
<svg width="100%" height="60vh" viewBox="0 -5 @measurements.Count 261">
    @for (int i = 1; i < measurements.Count; i++)
    {
        if (measurements[i] is not null)
        {
            <line x1="@(i-1)" x2="@i" y1="@measurements[i-1]" y2="@measurements[i]" stroke="red" stroke-width="2"></line>
        }
    }
</svg>

@code {
    AudioContext context = default!;
    GainNode gainNode = default!;
    GainSlider? gainSlider;
    OscillatorNode? oscillator;
    List<byte?> measurements = new();
    float frequency;
    OscillatorType type;
    bool makeMeasurements = false;
    int measurementDelay = 1;

    protected override async Task OnInitializedAsync()
    {
        context = await AudioContext.CreateAsync(JSRuntime);
        gainNode = await context.CreateGainAsync();

        AudioDestinationNode destination = await context.GetDestinationAsync();
        await gainNode.ConnectAsync(destination);
    }

    public async Task PlaySound()
    {
        await StopSound();
        type = (OscillatorType)Random.Shared.Next(0, 4);
        frequency = Random.Shared.Next(100, 500);

        AnalyserNode analyser = await context.CreateAnalyserAsync();
        await analyser.ConnectAsync(gainNode);

        oscillator = await OscillatorNode.CreateAsync(JSRuntime, context, new() { Type = type, Frequency = frequency });
        await oscillator.ConnectAsync(analyser);
        await oscillator.StartAsync();

        await Task.Delay(200);

        int bufferLength = (int)await analyser.GetFrequencyBinCountAsync();
        var dataArray = await Uint8Array.CreateAsync(JSRuntime, bufferLength);

        makeMeasurements = true;
        while (makeMeasurements)
        {
            await analyser.GetByteTimeDomainDataAsync(dataArray);

            measurements.Clear();
            for (int i = 0; i < bufferLength && makeMeasurements; i++)
            {
                measurements.Add(await dataArray.AtAsync(i));
            }
            await Task.Delay(measurementDelay);
            StateHasChanged();
        }
    }

    public async Task StopSound()
    {
        makeMeasurements = false;
        if (oscillator is null) return;
        await oscillator.StopAsync();
        oscillator = null;
    }

    public async ValueTask DisposeAsync()
    {
        await StopSound();
    }
}


